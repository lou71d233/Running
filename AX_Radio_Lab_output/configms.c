/* Warning: This file is automatically generated by AX-RadioLAB.
	Manual changes are overwritten! */

#include "configms.h"
#include "../COMMON/axradio.h"
#include "../COMMON/easyax5043.h"
/*
#if RADIO_MODE == AXRADIO_MODE_ASYNC_TRANSMIT
//old master
const struct axradio_address __code remoteaddr = {
    { 0x33, 0x34, 0x00, 0x00}
};
const struct axradio_address_mask __code localaddr = {
    { 0x32, 0x34, 0x00, 0x00},
    { 0xff, 0xff, 0x00, 0x00}
};
#endif

#if RADIO_MODE == AXRADIO_MODE_ASYNC_RECEIVE
//old slave

const struct axradio_address __code remoteaddr = {
    { 0x32, 0x34, 0x00, 0x00}
};
const struct axradio_address_mask __code localaddr = {
    { 0x33, 0x34, 0x00, 0x00},
    { 0xff, 0xff, 0x00, 0x00}
};
#endif
*/

#if RADIO_MODE == AXRADIO_MODE_ASYNC_TRANSMIT
//old master
struct axradio_address __xdata axradio_default_remoteaddr = {
    { 0x33, 0x34, 0x00, 0x00}
};
struct axradio_address_mask __xdata axradio_localaddr = {
    { 0x32, 0x34, 0x00, 0x00},
    { 0xff, 0xff, 0x00, 0x00}
};
#endif

#if RADIO_MODE == AXRADIO_MODE_ASYNC_RECEIVE
//old slave

struct axradio_address __xdata axradio_default_remoteaddr = {
    { 0x32, 0x34, 0x00, 0x00}
    /*
    { 0x35, 0x34, 0x00, 0x00}*/
};
struct axradio_address_mask __xdata axradio_localaddr = {
    { 0x33, 0x34, 0x00, 0x00},
    { 0xff, 0xff, 0x00, 0x00}
    /*
    { 0x36, 0x34, 0x00, 0x00},
    { 0xff, 0xff, 0x00, 0x00}*/

};
#endif

const uint8_t __code framing_insert_counter = 1;
const uint8_t __code framing_counter_pos = 0;

const uint16_t __code lposckfiltmax = 0xaec;


const uint16_t __code lpxosc_settlingtime = 3000;

//const uint8_t __code demo_packet[] =  { 0x00, 0x00, 0x01,	0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x20, 0x21};
const uint8_t __code demo_packet[Tx_packet_len+2];
const uint8_t __code packet_lock_wheel[Tx_packet_len+2]= {0x00,0x00,'A','T','+','S','E','T','@','L','O','C','K','_','W','H','E','E','L',' ',' ','0x0A'};
//const uint8_t __code packet_lock_wheel[Tx_packet_len+2]= {0x00,0x00,'AT+SET@LOCK_WHEEL',' ',' ','0x0A'};
const uint8_t __code packet_unlock_wheel[Tx_packet_len+2]={0x00,0x00,'A','T','+','S','E','T','@','U','N','L','O','C','K','_','W','H','E','E','L','0x0A'};
//const uint8_t __code packet_unlock_wheel[Tx_packet_len+2]={0x00,0x00,'AT+SET@UNOCK_WHEEL','0x0A'};

//uint8_t __code eep00[16],eep01[16],eep02[16];

void axradio_set_addr_Switch_Transmit(uint8_t *addr)
{
    // master
/*
    axradio_default_remoteaddr.addr[0] = 0x36;
    axradio_default_remoteaddr.addr[1] = 0x34;
    axradio_default_remoteaddr.addr[2] = 0x00;
    axradio_default_remoteaddr.addr[3] = 0x00;

    axradio_localaddr.addr[0] = 0x35;
    axradio_localaddr.addr[1] = 0x34;
    axradio_localaddr.addr[2] = 0x00;
    axradio_localaddr.addr[3] = 0x00;


    axradio_default_remoteaddr.addr[0] = 0x33;
    axradio_default_remoteaddr.addr[1] = 0x34;
    axradio_default_remoteaddr.addr[2] = 0x00;
    axradio_default_remoteaddr.addr[3] = 0x00;

    axradio_localaddr.addr[0] = 0x32;
    axradio_localaddr.addr[1] = 0x34;
    axradio_localaddr.addr[2] = 0x00;
    axradio_localaddr.addr[3] = 0x00;

*/
    axradio_default_remoteaddr.addr[0] = addr[8];
    axradio_default_remoteaddr.addr[1] = addr[9];
    axradio_default_remoteaddr.addr[2] = addr[10];
    axradio_default_remoteaddr.addr[3] = addr[11];

    axradio_localaddr.addr[0] = addr[0];
    axradio_localaddr.addr[1] = addr[1];
    axradio_localaddr.addr[2] = addr[2];
    axradio_localaddr.addr[3] = addr[3];

}

void axradio_set_addr_Switch_Receive(uint8_t *addr)
{
    // slave
/*
    axradio_default_remoteaddr.addr[0] = 0x35;
    axradio_default_remoteaddr.addr[1] = 0x34;
    axradio_default_remoteaddr.addr[2] = 0x00;
    axradio_default_remoteaddr.addr[3] = 0x00;

    axradio_localaddr.addr[0] = 0x36;
    axradio_localaddr.addr[1] = 0x34;
    axradio_localaddr.addr[2] = 0x00;
    axradio_localaddr.addr[3] = 0x00;


    axradio_default_remoteaddr.addr[0] = 0x32;
    axradio_default_remoteaddr.addr[1] = 0x34;
    axradio_default_remoteaddr.addr[2] = 0x00;
    axradio_default_remoteaddr.addr[3] = 0x00;

    axradio_localaddr.addr[0] = 0x33;
    axradio_localaddr.addr[1] = 0x34;
    axradio_localaddr.addr[2] = 0x00;
    axradio_localaddr.addr[3] = 0x00;

*/
    axradio_default_remoteaddr.addr[0] = addr[0];
    axradio_default_remoteaddr.addr[1] = addr[1];
    axradio_default_remoteaddr.addr[2] = addr[2];
    axradio_default_remoteaddr.addr[3] = addr[3];

    axradio_localaddr.addr[0] = addr[8];
    axradio_localaddr.addr[1] = addr[9];
    axradio_localaddr.addr[2] = addr[10];
    axradio_localaddr.addr[3] = addr[11];

}




void set_fm_tx(void)
{
    // this routine configures the AX5043 for analog FM TX
    // it is assumed that frequency, PLL, BW etc are already configured
    // from calling ax5043_set_registers(), ax5043_set_registers_tx()
    // only analog FM specific changes are applied here

    AX5043_MODULATION              = 0x0B; // analog FM

	AX5043_FSKDEV2                 = 0x00;
	AX5043_FSKDEV1                 = 0x00; // GPADC13, enable sign extension and offset (=midcode) subtraction
	AX5043_FSKDEV0                 = 0x00; // f_deviation = +/- 65kHz [max / min ADC value gives f_deviation = +/- f_xtal / 2^(AX5043_FSKDEV0+1), allowed values are 0..7.

    //AX5043_GPADCPERIOD             = 0x05; // F_s = f_xtal/32/GPADCPERIOD ---> 5 gives 100kHz @ f_xtal=16MHz. This determines the sampling rate, AX5043_TXRATE has no meaning in FM mode
    //AX5043_GPADCCTRL               = 0x06; // continuous sampling GPADC13

    AX5043_PINFUNCDATA             = 0x04; // Enables continuous TX operation, rather than powering up the PA only if there is committed FIFO data. This is similar to wire mode, except that no data is read from the pin in FM mode.
    AX5043_PWRMODE                 = 0x0D; // FULL TX

}

void set_fm_rx(void)
{
    // this routine configures the AX5043 for analog FM RX
    // it is assumed that frequency, PLL, BW etc are already configured
    // from calling ax5043_set_registers(), ax5043_set_registers_rx()
    // only analog FM specific changes are applied here

    AX5043_MODULATION              = 0x0B; // analog FM
/*
    AX5043_IFFREQ1                 = 0x06; // 25kHz at f_adc=1MHz (f_xtal=16MHz)
    AX5043_IFFREQ0                 = 0x66;
*/
    AX5043_RXPARAMSETS             = 0x00; // only use receiver parameter set 0

	AX5043_TIMEGAIN0               = 0x00; // disable bit timing recovery, which would only add jitter
	AX5043_DRGAIN0                 = 0x00;
/*
    AX5043_MAXDROFFSET2            = 0x00; // off
	AX5043_MAXDROFFSET1            = 0x00;
	AX5043_MAXDROFFSET0            = 0x00;

	AX5043_MAXRFOFFSET2            = 0x80; // track at LO1, max 50kHz @ f_xtal = 16MHz
	AX5043_MAXRFOFFSET1            = 0xCC;
	AX5043_MAXRFOFFSET0            = 0xCC;

	AX5043_FREQUENCYGAINA0         = 0x0F;
	AX5043_FREQUENCYGAINB0         = 0x02; // bandwidth of “inner?AFC loop used for FM demodulation. f_3dB = 0.115*BR. This is the fastest setting available

	AX5043_FREQUENCYGAINC0         = 0x1F;
	AX5043_FREQUENCYGAIND0         = 0x08; // bandwidth of “outer?AFC loop (tracking frequency mismatch), 78Hz @ BR=100kbps, f_xtal=16MHz

    AX5043_FREQUENCYLEAK = AX5043_FREQUENCYGAINB0 + 2; // prevents the demodulator AFC loop from tracking static frequency offsets
	AX5043_DACCONFIG               = 0x03; // output TRKFREQUENCY (=demodulated signal) on DAC
	AX5043_DACVALUE1               = 0x00;
	AX5043_DACVALUE0               = 0x0c; // DACSHIFT = 12 bit. This gives maximum volume. Downshifting further --> smaller volume
    AX5043_PINFUNCPWRAMP           = 0x05; // output DAC
*/
    AX5043_PWRMODE                 = 0x09; // FULL RX
}

void set_fm_done(void)
{
    // this routine configures the AX5043 for analog FM TX
    // it is assumed that frequency, PLL, BW etc are already configured
    // from calling ax5043_set_registers(), ax5043_set_registers_tx()
    // only analog FM specific changes are applied here

    AX5043_MODULATION              = 0x0B; // analog FM

	AX5043_FSKDEV2                 = 0x00;
	AX5043_FSKDEV1                 = 0x00; // GPADC13, enable sign extension and offset (=midcode) subtraction
	AX5043_FSKDEV0                 = 0x00; // f_deviation = +/- 65kHz [max / min ADC value gives f_deviation = +/- f_xtal / 2^(AX5043_FSKDEV0+1), allowed values are 0..7.

    //AX5043_GPADCPERIOD             = 0x05; // F_s = f_xtal/32/GPADCPERIOD ---> 5 gives 100kHz @ f_xtal=16MHz. This determines the sampling rate, AX5043_TXRATE has no meaning in FM mode
    //AX5043_GPADCCTRL               = 0x06; // continuous sampling GPADC13

    //AX5043_PINFUNCDATA             = 0x04; // Enables continuous TX operation, rather than powering up the PA only if there is committed FIFO data. This is similar to wire mode, except that no data is read from the pin in FM mode.
    AX5043_PWRMODE                 = 0x00; // FULL TX

}

